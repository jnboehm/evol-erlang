\chapter{Generalized Asymmetric Partition Crossover}

\section{Einleitung}
Der „Generalized Asymmetric Partition Crossover“ (GAPX) ist ein
Rekombinationsoperator, der als Teil eines evolutionären Algorithmus
verwendet werden kann. Aufgabe einer Rekombination beim ATSP ist es aus
zwei gegebenen Rundreisen $G_1$, $G_2$ ein Kind (auch Offspring genannt)
$G_o$ zu erzeugen.


\begin{algorithm}
\caption{Crossover in einem EA}\label{alg:crossover_ea}
\begin{algorithmic}[1]
\Procedure{Crossover}{$G_1,G_2$}\Comment{}
\State $G_o\gets gapx(G_1,G_2)$\Comment{In 2.2 beschrieben}
\State \textbf{return} $G_o$
\EndProcedure
\end{algorithmic}
\end{algorithm}
GAPX versucht durch ein bestimmtes Verfahren die beiden Rundreisen zu
partitionieren und daraus das neue Kind $G_o$ zu erzeugen.


\section{Funktionsweise}
Seien $G_1$ und $G_2$ beliebige Rundreisen, beide erzeugt aus einem
vollständigen Graphen $G_c$. Zunächst werden $G_1$ und $G_2$ in einem
gemeinsamen Graphen $G_u$ zusammengeführt. Den Graph $G_u = G_1 \cup
G_2$ nennen wir auch Vereinigungsgraph von $G_1$ und $G_2$.
\newpage
%% Bild mergen von G1, G2
\begin{figure}[hb]
\centering
\renewcommand{\arraystretch}{3.5}
\begin{tabular}{ c c c }
$G_1$ & $G_2$ & $G_u$ \\
\resizebox{90pt}{90pt}{

  \begin{tikzpicture}[%
    >=stealth,
    node distance=2cm,
    on grid,
    auto
  ]
  \node[state] (1){1};
  \node[state] (3) [above right of=1]{3};
  \node[state] (2) [below right of=1]{2};
  \node[state] (4) [below right of=3]{4};
  
  \path[->] (1) edge [blue, bend left=0] node  {} (3);
  \path[->] (3) edge [blue, bend left=0] node  {} (2);
  \path[->] (2) edge [blue, bend left=0] node  {} (4);
  \path[->] (4) edge [blue, bend left=0] node  {} (1);
  
  \end{tikzpicture}
} 

& 

\resizebox{90pt}{90pt}{

  \begin{tikzpicture}[%
    >=stealth,
    node distance=2cm,
    on grid,
    auto
  ]
  \node[state] (1){1};
  \node[state] (3) [above right of=1]{3};
  \node[state] (2) [below right of=1]{2};
  \node[state] (4) [below right of=3]{4};

  \path[->] (1) edge [red, dashed, left=0] node  {} (2);
  \path[->] (2) edge [red, dashed, left=0] node  {} (3);
  \path[->] (3) edge [red, dashed, left=0] node  {} (4);
  \path[->] (4) edge [red, dashed, left=0] node  {} (1);

  \end{tikzpicture}
} 

&

\resizebox{90pt}{90pt}{

  \begin{tikzpicture}[%
    >=stealth,
    node distance=2cm,
    on grid,
    auto
  ]
  \node[state] (1){1};
  \node[state] (3) [above right of=1]{3};
  \node[state] (2) [below right of=1]{2};
  \node[state] (4) [below right of=3]{4};

  \path[->] (1) edge [blue, bend left=0] node  {} (3);
  \path[->] (3) edge [blue, bend left=0] node  {} (2);
  \path[->] (2) edge [blue, bend left=0] node  {} (4);
  \path[->] (4) edge [blue, bend left=0] node  {} (1);

  \path[->] (1) edge [red, dashed, left=0] node  {} (2);
  \path[->] ([xshift=0.4em] 2.north) edge 
      [red, dashed, left=0] node  {} ([xshift=0.4em] 3.south);
  \path[->] (3) edge [red, dashed, left=0] node  {} (4);
  \path[->] ([yshift=0.4em] 4.west) edge 
      [red, dashed, left=0] node  {} ([yshift=0.4em] 1.east);

  \end{tikzpicture}
} 
\end{tabular}
\renewcommand{\arraystretch}{1}
\caption[Beispiel einer Zusammenlegung von Graphen]{
Beispiel für das Zusammenführen der Graphen $G_1$ und $G_2$ zu
dem neuen Graphen $G_u$ anhand zwei Rundreisen mit je vier Knoten.
}
\end{figure}
%%\begin{bem}
%%  Streng genommen ist $G_u$ ein Multigraph, da doppelte Kanten zwischen
%%  Knoten existieren können, jedoch hat dies die Implementierung nicht
%%  eingeschränkt, da ein „normaler Graph“ eine Spezielform eines
%%  Multigraphen ist.
%%\end{bem}
Nach der Zusammenführung der beiden Graphen in $G_u$ muss für alle
Knoten $v$ aus $G_u$ bei der die Bedingung $deg(v) = 4$ erfüllt ist ein
sogenannter Ghost-Knoten $v'$ eingeführt werden. Zusätzlich muss eine
Kante mit dem Gewicht $0$ zwischen $v$ und $v'$ eingefügt werden. 
Der Graph $G_u$ mit eingefügten Ghost-Knoten an den entsprechenden Stellen kennzeichnen wir als $G_u'$.
\begin{figure}[hb]
\centering
\begin{tabular}{ c c }
\resizebox{120pt}{170pt}{
\begin{tikzpicture}[%
>=stealth,
node distance=1.7cm,
on grid
]
\node[state] (1)              {1};


\node[state] (3) [above right of=1]             {3};
\node[state] (2) [below right of=1]            {2};
\node[state] (4) [right of=3]             {4};
\node[state] (5) [right of=2]             {5};

\node[state] (6) [below right of=5] {6};

\node[state] (7) [below left of=6] {7};
\node[state] (10) [left of=7] {10};

\node[state] (11) [below left of=10] {11};

\node[state] (9) [below right of=11] {9};
\node[state] (8) [right of=9] {8};

% solid: parent 1
\path[->] (1) edge [blue, bend left=0] node  {} (3);
\path[->] (3) edge [blue, bend left=0] node  {} (2);
\path[->] (2) edge [blue, bend left=0] node  {} (5);
\path[->] (5) edge [blue, bend left=0] node  {} (4);
\path[->] (4) edge [blue, bend left=0] node  {} (6);
\path[->] (6) edge [blue, bend left=0] node  {} (8);
\path[->] (8) edge [blue, bend left=0] node  {} (7);
\path[->] (7) edge [blue, bend left=0] node  {} (10);
\path[->] (10) edge [blue, bend left=0] node  {} (9);
\path[->] (9) edge [blue, bend left=0] node  {} (11);
\path[->] (11) edge [blue, bend left=0] node  {} (1);

% dashed: parent 2
\path[->] (1) edge [bend left=0, dashed, red] node {} (2);
\path[->] ([xshift=0.7ex] 2.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 3.south);
\path[->] (3) edge [red, dashed] node {}
         (4);
\path[->] ([xshift=0.7ex] 4.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 5.north);
\path[->] (5) edge [red, dashed] node {}
         (6);
\path[->] (6) edge [red, dashed] node {}
         (7);
\path[->] ([xshift=0.7ex] 7.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 8.north);
\path[->] (8) edge [red, dashed] node {}
         (9);
\path[->] ([xshift=0.7ex] 9.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 10.south);
\path[->] (10) edge [red, dashed] node {}
         (11);
\path[->] ([xshift=0.7ex] 11.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 1.south);
\end{tikzpicture}
}

&
\resizebox{120pt}{170pt}{
\begin{tikzpicture}[%
>=stealth,
node distance=1.9cm,
on grid,
auto
]
\node[state] (1){1};
\node[state] (3) [above right of=1]{3};
\node[state] (2) [below right of=1]{2};
\node[state] (4) [right of=3]{4};
\node[state] (5) [right of=2]{5};
\node[state] (6) [above right of=5] {6};
\node[state] (7) [below of=5] {7};
\node[state] (6') [below right of=7] {6'};
\node[state] (10) [left of=7] {10};
\node[state] (11) [below left of=10] {11};
\node[state] (9) [below right of=11] {9};
\node[state] (8) [right of=9] {8};

% solid: parent 1
\path[->] (1) edge [blue, bend left=0] node  {} (3);
\path[->] (3) edge [blue, bend left=0] node  {} (2);
\path[->] (2) edge [blue, bend left=0] node  {} (5);
\path[->] (5) edge [blue, bend left=0] node  {} (4);
\path[->] (6') edge [blue, bend left=0] node  {} (8);
\path[->] (4) edge [blue, bend left=0] node  {} (6);
\path[->] (8) edge [blue, bend left=0] node  {} (7);
\path[->] (7) edge [blue, bend left=0] node  {} (10);
\path[->] (10) edge [blue, bend left=0] node  {} (9);
\path[->] (9) edge [blue, bend left=0] node  {} (11);
\path[->] (11) edge [blue, bend left=0] node  {} (1);
\path[->] (6) edge [blue, bend left=0] node  {} (6');

% dashed: parent 2
\path[->] (1) edge [bend left=0, dashed, red] node {} (2);
\path[->] ([xshift=0.7ex] 2.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 3.south);
\path[->] (3) edge [red, dashed] node {}
         (4);
\path[->] ([xshift=0.7ex] 4.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 5.north);
\path[->] (5) edge [red, dashed] node {}
         (6);
\path[->] (6') edge [red, dashed] node {}
         (7);
\path[->] ([xshift=0.7ex] 7.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 8.north);
\path[->] (8) edge [red, dashed] node {}
         (9);
\path[->] ([xshift=0.7ex] 9.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 10.south);
\path[->] (10) edge [red, dashed] node {}
         (11);
\path[->] ([xshift=0.7ex] 11.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 1.south);
  \path[->] ([xshift=0.7ex] 6.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 6'.north);

\end{tikzpicture}
}
\end{tabular}
\caption[Beispiel Einfügung von Ghost-Knoten]{Links: Ein Graph $G_u$ vor der Einführung von
Ghostknoten. Rechts: Der Graph mit dem eingefügten Ghostknoten $6'$.
Blaue Linie: $G_1$, erstes Elternteil; rote, gestrichelte Linie: $G_2$,
zweites Elternteil}
\end{figure}
\begin{bem}
Es hat sich herausgestellt, dass es bei der Implementierung einfacher war die
Anzahl der Nachbarn von $v$ anzuschauen, um herauszufinden, ob ein
Ghost-Knoten $v'$ eingefügt werden muss, oder nicht.
\end{bem}
\newpage
Nachdem alle Ghost-Knoten eingefügt wurden müssen Kanten mit einer
bestimmten Eigenschaft aus $G_u'$ entfernt werden um eine Paritionierung
des Graphen vorzunehmen. In $G_u'$ müssen genau jene Kanten entfernt
werden, die sowohl in $G_1$ \textbf{und} $G_2$ vorkommen. Zusätzlich
müssen die Kanten entfernt werden, die bei der Generierung der
Ghost-Knoten neu eingefügt wurden. In Abbildung 2.2 wäre dies die Kante
zwischen $6$ und $6'$. Die Menge dieser entfernten Kanten nennen wir
nachfolgend $E_c$ und werden auch „Common-Edges“ genannt. Die Menge
beinhaltet also genau die Kanten die in beiden Elternteilen vorkommen. Die
Menge $E_c$ wird nun in die Kantenmenge von $G_o$ (dem Offspring)
eingefügt.
\begin{figure}[hb]
\centering
\resizebox{120pt}{170pt}{
\begin{tikzpicture}[%
>=stealth,
node distance=1.9cm,
on grid,
auto
]
\node[state] (1){1};
\node[state] (3) [above right of=1]{3};
\node[state] (2) [below right of=1]{2};
\node[state] (4) [right of=3]{4};
\node[state] (5) [right of=2]{5};
\node[state] (6) [above right of=5] {6};
\node[state] (7) [below of=5] {7};
\node[state] (6') [below right of=7] {6'};
\node[state] (10) [left of=7] {10};
\node[state] (11) [below left of=10] {11};
\node[state] (9) [below right of=11] {9};
\node[state] (8) [right of=9] {8};

% solid: parent 1
\path[->] (11) edge [bend left=0] node  {} (1);
\path[->] (6) edge [bend left=0] node  {} (6');

\end{tikzpicture}
}
  \caption[Kind $G_o$ nach Einfügen der gemeinsamen Kantenmenge $E_c$]
  {Das Kind $G_o$ im momentanen Zustand. In Abbildung 2.2 sind Ghost-Knoten eingefügt
  worden. $E_c = \{(6,6'),(1,11)\}$. Die Kante $(6,6')$ ist durch das
  Einfügen eines Ghost-Knoten entstanden. Die Kante $(1,11)$ ist in beiden
  Rundreisen $G_1$ und $G_2$ vorhanden. $E_c$ wurde in $G_o$ eingefügt.}
\end{figure}
\newpage
Durch das Entfernen von $E_c$ in $G_u'$ haben wir eine Partitionierung
des Graphen erreicht. Der Graph $G_u'$ wurde in seine Komponenten
zerlegt.
\begin{figure}[bh]
\centering
  \begin{tabular}{c c}
\resizebox{120pt}{170pt}{
\begin{tikzpicture}[%
>=stealth,
node distance=1.9cm,
on grid,
auto
]
\node[state] (1){1};
\node[state] (3) [above right of=1]{3};
\node[state] (2) [below right of=1]{2};
\node[state] (4) [right of=3]{4};
\node[state] (5) [right of=2]{5};
\node[state] (6) [above right of=5] {6};
\node[state] (7) [below of=5] {7};
\node[state] (6') [below right of=7] {6'};
\node[state] (10) [left of=7] {10};
\node[state] (11) [below left of=10] {11};
\node[state] (9) [below right of=11] {9};
\node[state] (8) [right of=9] {8};

% solid: parent 1
\path[->] (1) edge [blue, bend left=0] node  {} (3);
\path[->] (3) edge [blue, bend left=0] node  {} (2);
\path[->] (2) edge [blue, bend left=0] node  {} (5);
\path[->] (5) edge [blue, bend left=0] node  {} (4);
\path[->] (6') edge [blue, bend left=0] node  {} (8);
\path[->] (4) edge [blue, bend left=0] node  {} (6);
\path[->] (8) edge [blue, bend left=0] node  {} (7);
\path[->] (7) edge [blue, bend left=0] node  {} (10);
\path[->] (10) edge [blue, bend left=0] node  {} (9);
\path[->] (9) edge [blue, bend left=0] node  {} (11);
\path[->] (11) edge [blue, bend left=0] node  {} (1);
\path[->] (6) edge [blue, bend left=0] node  {} (6');

% dashed: parent 2
\path[->] (1) edge [bend left=0, dashed, red] node {} (2);
\path[->] ([xshift=0.7ex] 2.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 3.south);
\path[->] (3) edge [red, dashed] node {}
         (4);
\path[->] ([xshift=0.7ex] 4.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 5.north);
\path[->] (5) edge [red, dashed] node {}
         (6);
\path[->] (6') edge [red, dashed] node {}
         (7);
\path[->] ([xshift=0.7ex] 7.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 8.north);
\path[->] (8) edge [red, dashed] node {}
         (9);
\path[->] ([xshift=0.7ex] 9.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 10.south);
\path[->] (10) edge [red, dashed] node {}
         (11);
\path[->] ([xshift=0.7ex] 11.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 1.south);
  \path[->] ([xshift=0.7ex] 6.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 6'.north);

\end{tikzpicture}
}
&
\resizebox{120pt}{170pt}{
\begin{tikzpicture}[%
>=stealth,
node distance=1.9cm,
on grid,
auto
]
\node[state] (1){1};
\node[state] (3) [above right of=1]{3};
\node[state] (2) [below right of=1]{2};
\node[state] (4) [right of=3]{4};
\node[state] (5) [right of=2]{5};
\node[state] (6) [above right of=5] {6};
\node[state] (7) [below of=5] {7};
\node[state] (6') [below right of=7] {6'};
\node[state] (10) [left of=7] {10};
\node[state] (11) [below left of=10] {11};
\node[state] (9) [below right of=11] {9};
\node[state] (8) [right of=9] {8};

% solid: parent 1
\path[->] (1) edge [blue, bend left=0] node  {} (3);
\path[->] (3) edge [blue, bend left=0] node  {} (2);
\path[->] (2) edge [blue, bend left=0] node  {} (5);
\path[->] (5) edge [blue, bend left=0] node  {} (4);
\path[->] (6') edge [blue, bend left=0] node  {} (8);
\path[->] (4) edge [blue, bend left=0] node  {} (6);
\path[->] (8) edge [blue, bend left=0] node  {} (7);
\path[->] (7) edge [blue, bend left=0] node  {} (10);
\path[->] (10) edge [blue, bend left=0] node  {} (9);
\path[->] (9) edge [blue, bend left=0] node  {} (11);

% dashed: parent 2
\path[->] (1) edge [bend left=0, dashed, red] node {} (2);
\path[->] ([xshift=0.7ex] 2.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 3.south);
\path[->] (3) edge [red, dashed] node {}
         (4);
\path[->] ([xshift=0.7ex] 4.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 5.north);
\path[->] (5) edge [red, dashed] node {}
         (6);
\path[->] (6') edge [red, dashed] node {}
         (7);
\path[->] ([xshift=0.7ex] 7.south) edge [red, dashed] node {}
         ([xshift=0.7ex] 8.north);
\path[->] (8) edge [red, dashed] node {}
         (9);
\path[->] ([xshift=0.7ex] 9.north) edge [red, dashed] node {}
         ([xshift=0.7ex] 10.south);
\path[->] (10) edge [red, dashed] node {}
         (11);

\end{tikzpicture}
}

\end{tabular}
\caption[Partitionierung von $G_u'$ nach Löschen von $E_c$]{Der Graph
$G_u$ nach Löschen der gemeinsamen Kanten $E_c$. Die Teile des
partitionierten Graphen werden Komponenten genannt.}
\end{figure}

Jede Komponente wird als Teilgraph $G_{p_k}$ gekennzeichnet, wobei $k
\leq $Anzahl der Komponenten in $G_u'$.  

\begin{bem}
  In Abbildung 2.4 ist $G_{p_1}$ ist der Teilgraph mit den Knoten $1,2,3,4,5,6$, $G_{p_2}$ ist der Teilgraph
  mit den Knoten
  $11,9,10,7,8,6'$
\end{bem}
Für alle Komponenten $G_{p_k}$ muss als nächstes die Menge der Eingangs- und
Ausgangsknoten festgestellt werden. Hierfür werden zwei Funktionen
definiert:
\begin{itemize}
  \item $comp_{in}(G_{p_k}, E_c)$ - ermittelt die Menge der
    Eingangsknoten von $G_{p_k}$ 
  \item $comp_{out}(G_{p_k}, E_c)$ - ermittelt die Menge der
    Ausgangsknoten von $G_{p_k}$ 
\end{itemize}
\newpage
\begin{algorithm}
  \caption{Ermittlung Eingangsknoten in $G_{p_k}$}\label{alg:comp_in}
\begin{algorithmic}[1]
  \Procedure{$comp_{in}$}{$G_{p_k}, E_c$}
    \State $V \gets vertices(G_{p_k})$
    \State $Entry \gets list()$
    \Foreach{$v \in V$}
      \State $g = has\_ghostnode\_in\_comp(G_{p_k}, v)$
      \If {$\neg g \land in\_degree(G_{p_k}, v) = 0$}
      \Comment{// In-Degree}    
        \State $Entry \gets append(Entry, v)$
      \EndIf
    \EndForeach
    \State \textbf{return} $Entry$
  \EndProcedure
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{Ermittlung Ausgangsknoten in $G_{p_k}$}\label{alg:comp_out}
\begin{algorithmic}[1]
  \Procedure{$comp_{out}$}{$G_{p_k}, E_c$}
    \State $V \gets vertices(G_{p_k})$
    \State $Entry \gets list()$
    \Foreach{$v \in V$}
      \State $g = has\_ghostnode\_in\_comp(G_{p_k}, v)$
      \If {$\neg g \land out\_degree(G_{p_k}, v) = 0$}
      \Comment{// Out-Degree} 
        \State $Entry \gets append(Entry, v)$
      \EndIf
    \EndForeach
    \State \textbf{return} $Entry$
  \EndProcedure
\end{algorithmic}
\end{algorithm}
\begin{bem}
  Es können Komponenten existieren welche nicht nur einen Eingangs- und
  einen Ausgangsknoten haben. Tatsächlich gibt es sehr häufig
  Partitionierungen mit Komponenten, die drei oder vier Eingängen
  beziehungsweise Ausgängen haben. Die Algorithmen 3 und 4 beachten
  diesen Umstand.
\end{bem}
\begin{bem}
  Die Funktion $has\_ghostnode\_in\_comp(G_{p_k}, v)$ ist hier nicht
  ausführlich erläutert. Sie überprüft, ob für einen Knoten $v$ ein
  entsprechender Ghost-Knoten $v'$ eingefügt wurde, der sich ebenfalls
  innerhalb der Komponente $G_{p_k}$ befindet. Ist dies der Fall, gibt
  die Funktion den Wert true zurück. 
\end{bem}
\newpage
\section{Implementierung}
