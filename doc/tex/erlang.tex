\chapter{Erlang}
Da wir den Algorithmus durch „message passing“ parallelisieren wollten
haben wir uns für Erlang als unsere Programmiersprache verwendet.  Die
Sprache wurde im „Ericsson Computer Science Laboratory“ entwickelt um
vor allem Telekommunikationsanwendungen zu entwickeln, wo viel Wert
auf Nachrichtenaustausch und Distribution gelegt wird.

Erlang ist eine funktionale Programmiersprache, obwohl einzelne
Prinzipien gebrochen werden, wenn praktische Probleme dies gebieten.
Zum Beispiel wird referenzielle Transparenz – „Ein Ausdruck kann mit
seinem Ergebnis ersetzt werden, ohne die Korrektheit des Programms zu
ändern“ – in Einzelfällen gebrochen, damit das Ergebnis von
\lstinline!now()! überhaupt sinnvoll sein kann.

Da Erlangs Prozesse initial deutlich weniger Speicher benötigen, sind
sie deutlich leichter als ein Systemprozess.  Die Nebenläufigkeit wird
in Erlang mittels threads realisiert, deren Scheduling von der Erlang
Runtime selber betrieben wird.  Der Unterschied zu vielen anderen
Sprachen ist dabei, dass das Scheduling „preemptive“ ist, dem
rechnenden Prozess also der Kern entzogen werden kann.

Ein Erlang Prozess entspricht ungefähr einer Node.  Diese kann nach
einmaliger Verbindung mit anderen Nodes kommunizieren, was ebenfalls
mit Erlangs „message passing“ funktioniert.  Für mehr Details dazu
siehe \cite[Kapitel~„Distribunomicon“]{lyse}.

\section{Vorteile}
Erlang hat sich hervorragend geeignet, das Programm nebenläufig zu
machen.  Deshalb fiel unsere Wahl überhaupt erst auf die Sprache.

Das Versenden und Empfangen von Nachrichten ist extrem einfach durch
das „pattern matching“ von Erlang.  In dem Modul \lstinline!digraph!
werden Graphen als Tupel \lstinline!{digraph, V, E, N, true}!
dargestellt.  \lstinline!V!, \lstinline!E! und \lstinline!N! werden
intern als Datenbanktabellen gehalten, auf die jeder Prozess in einer
Node zugreifen kann, weshalb nur die Referenz auf die Tabellen
versendet werden muss.

Auch kann man durch Nachrichten ein Interface für den Benutzer
erstellen, in dem man an dem Hauptprozess eine Nachricht schickt und
er darauf antwortet.  Darüber hinaus gibt es Profiler wie
\lstinline!eprof!, welche einem die Flaschenhälse aufzeigen, an denen
man noch Optimierungen vornehmen kann.

\section{Nachteile}
Für rechenintensive Aufgaben ist Elang ungeeignet.  Dynamische
Sprachen haben generell das Problem, dass sie Typinformationen zur
Laufzeit haben müssen und der Kompiler deshalb weniger Optimierungen
vornehmen kann.  Es führt außerdem dazu, dass der Typ zur Laufzeit
überprüft werden muss, was ebenfalls Rechenzeit kostet.

Generell wird davon abgeraten, die Sprache für solche Zwecke zu
benutzen, da Erlang dafür nicht konzipiert wurde.
\cite[Kapitel~3]{lyse}


Das wird im Detail in Kapitel \ref{chp:para}
behandelt.
