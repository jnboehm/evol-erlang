\chapter{Erlang}
Da wir den Algorithmus durch „message passing“ parallelisieren wollten
haben wir uns für Erlang als unsere Programmiersprache verwendet.  Die
Sprache wurde im „Ericsson Computer Science Laboratory“ entwickelt um
vor allem Telekommunikationsanwendungen zu entwickeln, wo viel Wert
auf Nachrichtenaustausch und Distribution gelegt wird.

Erlang ist eine funktionale Programmiersprache, obwohl einzelne
Prinzipien gebrochen werden, wenn praktische Probleme dies gebieten.
Zum Beispiel wird referenzielle Transparenz – „Ein Ausdruck kann mit
seinem Ergebnis ersetzt werden, ohne die Korrektheit des Programms zu
ändern“ – in Einzelfällen gebrochen, damit das Ergebnis von
\lstinline!now()! überhaupt sinnvoll sein kann.

\section{Vorteile}
Erlang hat sich hervorragend geeignet, das Programm nebenläufig zu
machen.  Deshalb fiel unsere Wahl überhaupt erst auf die Sprache.

Das Versenden und Empfangen von Nachrichten ist extrem einfach durch
das „pattern matching“ von Erlang.  Da wir das Modul
% Darstellung von Graphen
\lstinline{digraph} für unsere Datenstruktur verwenden, wurden diese
als Tupel \lstinline!{digraph, V, E, N, true}!  dargestellt.
\lstinline!V!, \lstinline!E! und \lstinline!N! werden intern als
Datenbanktabellen gehalten, auf die jeder Prozess in einer Node
zugreifen kann, %was ist ein proz. und node?
deshalb war es extrem einfach, einen Graphen zu versenden, da der
Empfänger nur die Referenz auf die Tabellen braucht.
\section{Nachteile}
Für rechenintensive Aufgaben ist Elang schlicht ungeeignet.
Dynamische Sprachen haben generell das Problem, dass sie
Typinformationen zur Laufzeit haben müssen und der Kompiler deshalb
weniger Optimierungen vornehmen kann.

Generell wird davon abgeraten, die Sprache für solche Zwecke zu
benutzen, da Erlang dafür nicht konzipiert wurde.
\cite[Kapitel~3]{lyse}

Das wird im Detail in Kapitel \ref{chp:para}
behandelt.
