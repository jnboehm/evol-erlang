\chapter{Erlang}
Da wir den Algorithmus durch „message passing“ parallelisieren wollten
haben wir uns für Erlang als unsere Programmiersprache verwendet.  Die
Sprache wurde im „Ericsson Computer Science Laboratory“ entwickelt um
vor allem Telekommunikationsanwendungen zu entwickeln, wo viel Wert
auf Nachrichtenaustausch und Distribution gelegt wird.

Erlang ist eine funktionale Programmiersprache, obwohl einzelne
Prinzipien gebrochen werden, wenn praktische Probleme dies gebieten.
Zum Beispiel wird referenzielle Transparenz – „Ein Ausdruck kann mit
seinem Ergebnis ersetzt werden, ohne die Korrektheit des Programms zu
ändern“ – in Einzelfällen gebrochen, damit das Ergebnis von
\lstinline!now()! überhaupt sinnvoll sein kann.

Da Erlangs Prozesse initial deutlich weniger Speicher benötigen, sind
sie deutlich leichter als ein Systemprozess.  Die Nebenläufigkeit wird
in Erlang mittels threads realisiert, deren Scheduling von der Erlang
Runtime selber betrieben wird.  Der Unterschied zu vielen anderen
Sprachen ist dabei, dass das Scheduling „preemptive“ ist, dem
rechnenden Prozess also der Kern entzogen werden kann.

Ein Erlang Prozess entspricht ungefähr einer Node.  Diese kann nach
einmaliger Verbindung mit anderen Nodes kommunizieren, was ebenfalls
mit Erlangs „message passing“ funktioniert.  Für mehr Details dazu
siehe \cite[Kapitel~„Distribunomicon“]{lyse}.

\section{Vorteile}
Erlang hat sich hervorragend geeignet, das Programm nebenläufig zu
machen.  Deshalb fiel unsere Wahl überhaupt erst auf die Sprache.

Das Versenden und Empfangen von Nachrichten ist extrem einfach durch
das „pattern matching“ von Erlang.  In dem Modul \lstinline!digraph!
werden Graphen als Tupel \lstinline!{digraph, V, E, N, true}!
dargestellt.  \lstinline!V!, \lstinline!E! und \lstinline!N! werden
intern als Datenbanktabellen gehalten, auf die jeder Prozess in einer
Node zugreifen kann, weshalb nur die Referenz auf die Tabellen
versendet werden muss.

Auch kann man durch Nachrichten ein Interface für den Benutzer
erstellen, in dem man an dem Hauptprozess eine Nachricht schickt und
er darauf antwortet.  Darüber hinaus gibt es Profiler wie
\lstinline!eprof!, welche einem die Flaschenhälse aufzeigen, an denen
man noch Optimierungen vornehmen kann.

\section{Nachteile}
\label{sec:disadv}
Für rechenintensive Aufgaben ist Erlang ungeeignet.  Dynamische
Sprachen haben generell das Problem, dass sie Typinformationen zur
Laufzeit haben müssen und der Kompiler deshalb weniger Optimierungen
vornehmen kann.  Es führt außerdem dazu, dass der Typ zur Laufzeit
überprüft werden muss, was ebenfalls Rechenzeit kostet.

Generell wird davon abgeraten, die Sprache für solche Zwecke zu
benutzen, da Erlang dafür nicht konzipiert wurde
\cite[Kapitel~3]{lyse}.

\subsection{\gtwght}
\label{subsec:get-weight}

Die Funktion \gtwght\ hat uns das Gewicht zwischen zwei Knoten in dem
Graphen zurückgegeben.  Als wir unseren Profiler benutzt haben,
stellte sich heraus, dass über 90\% der Aufrufe, und damit auch ein
Großteil der Zeit, dieser Funktion zufallen.  Deshalb hatten wir
versucht \gtwght\ zu optimieren, da die Anzahl der Aufrufe nicht
reduzieren werden konnte.

Zu erst wurde die Funktion so geschrieben, dass \gtwght\ den Graphen
selbst übergeben bekommt und dann auf dessen Tabellen eine
Datenbankabfrage macht.  Obwohl die In-Memory-Datenbank, in Erlang
wird diese ets genannt, einen konstanten Zeitaufwand für Lese- und
Schreiboperationen hat, war die konstante Zeit zu hoch.  Deshalb haben
wir vorher eine Liste mit allen Kanten erstellt aus denen wir mit
Hilfe von „pattern matching“ direkt den gefundenen Wert zurückgeben
konnten.  Das hatte uns eine durchschnittliche Zeit von 0,13 Sekunden
pro Aufruf erbracht.

Da immer noch die Laufzeit von \gtwght\ dominiert wurde, hatten wir
weiterhin versucht durch eine „Native Implemented Function“ (NIF) in C
die Zeit pro Aufruf zu reduzieren.  Das Resultat hat die Zeit pro
Aufruf leider verschlechtert, da die Makros für die Datenkonvertierung
(von Erlangs dynamischen Termen zu C-Typen) zu viel Zeit beansprucht.

Das war einer der Punkte, der im Nachhinein die Laufzeit drastisch
verschlechtert hat.  Es gibt in Erlang zwar auch Arrays, diese sind
allerdings funktional und bieten vor allem keinen wahlfreien
Speicherzugriff \cite[Kapitel~11]{lyse}.  Dieser Teil wäre in einer
Sprache wie C schnell und intuitiv gewesen, da einfach nur ein Zugriff
auf ein zweidimensionales Array an den übergebenen Indizes nötig
gewesen wäre.
